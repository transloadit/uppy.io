# Remix

Integration guide for the [React][] components for the Uppy UI plugins and
hooks.

:::tip Uppy also has hooks and more React examples in the
[React docs](/docs/react). :::

## Install

```shell
npm install @uppy/core @uppy/dashboard @uppy/react
```

## Tus

[Tus][tus] is an open protocol for resumable uploads built on HTTP. This means
accidentally closing your tab or losing connection lets you continue, for
instance, your 10GB upload instead of starting all over.

Tus supports any language, any platform, and any network. It requires a client
and server integration to work. We will be using [tus Node.js][].

Checkout the [`@uppy/tus` docs](/docs/tus) for more information.

```tsx
// app/routes/upload.tsx
import { useEffect, useState } from 'react';
import Uppy from '@uppy/core';
import Dashboard from '@uppy/react/lib/Dashboard';
import Tus from '@uppy/tus';

import '@uppy/core/dist/style.min.css';
import '@uppy/dashboard/dist/style.min.css';

function createUppy() {
	return new Uppy().use(Tus, { endpoint: '/api/upload' });
}

export default function UppyDashboard() {
	// Important: use an initializer function to prevent the state from recreating.
	const [uppy] = useState(createUppy);

	return <Dashboard theme="dark" uppy={uppy} />;
}
```

For the server component, create a new file to handle the tus uploads:

```ts
// app/routes/api.upload.ts
import { Server } from '@tus/server';
import { FileStore } from '@tus/file-store';
import type { LoaderFunction } from '@remix-run/node';

const tusServer = new Server({
	path: '/api/upload',
	datastore: new FileStore({ directory: './files' }),
});

export const loader: LoaderFunction = async ({ request }) => {
	return await tusServer.handle(request);
};

export const action = loader;
```

## Transloadit

:::note Before continuing you should have a
[Transloadit](https://transloadit.com) account and a
[template](https://transloadit.com/docs/getting-started/my-first-app/) setup.
:::

Transloadit's strength is versatility. By doing video, audio, images, documents,
and more, you only need one vendor for [all your file processing
needs][transloadit-services]. The [`@uppy/transloadit`](/docs/transloadit)
plugin directly uploads to Transloadit so you only have to worry about creating
a [template][transloadit-concepts]. It uses [Tus](#tus) under the hood so you
don't have to sacrifice reliable, resumable uploads for convenience.

When you go to production always make sure to set the `signature`. **Not using
[Signature Authentication](https://transloadit.com/docs/topics/signature-authentication/)
can be a security risk**. Signature Authentication is a security measure that
can prevent outsiders from tampering with your Assembly Instructions.

Generating a signature should be done on the server to avoid leaking secrets.

```ts
// app/routes/transloadit-params.ts
import { json } from '@remix-run/node';
import type { ActionFunction } from '@remix-run/node';
import crypto from 'crypto';

function utcDateString(ms: number): string {
	return new Date(ms)
		.toISOString()
		.replace(/-/g, '/')
		.replace(/T/, ' ')
		.replace(/\.\d+Z$/, '+00:00');
}

export const action: ActionFunction = async ({ request }) => {
	// expire 1 hour from now (this must be milliseconds)
	const expires = utcDateString(Date.now() + 1 * 60 * 60 * 1000);
	const authKey = process.env.TRANSLOADIT_KEY;
	const authSecret = process.env.TRANSLOADIT_SECRET;
	const templateId = process.env.TRANSLOADIT_TEMPLATE_ID;

	if (!authKey || !authSecret || !templateId) {
		throw json({ error: 'Missing Transloadit credentials' }, { status: 500 });
	}

	const body = await request.json();
	const params = JSON.stringify({
		auth: {
			key: authKey,
			expires,
		},
		template_id: templateId,
		fields: {
			// You can use this in your template.
			userId: body.userId,
		},
		// your other params like notify_url, etc.
	});

	const signatureBytes = crypto
		.createHmac('sha384', authSecret)
		.update(Buffer.from(params, 'utf-8'));
	// The final signature needs the hash name in front, so
	// the hashing algorithm can be updated in a backwards-compatible
	// way when old algorithms become insecure.
	const signature = `sha384:${signatureBytes.digest('hex')}`;

	return json({ expires, signature, params });
};
```

On the client we want to fetch the signature and params from the server. You may
want to send values from React state along to your endpoint, for instance to add
[`fields`](https://transloadit.com/docs/topics/assembly-variables/) which you
can use in your template as global variables.

```js
// app/routes/upload-transloadit.tsx
import { Transloadit } from '@uppy/transloadit';

function createUppy() {
	const uppy = new Uppy();
	uppy.use(Transloadit, {
		async assemblyOptions() {
			// You can send meta data along for use in your template.
			// https://transloadit.com/docs/topics/assembly-instructions/#form-fields-in-instructions
			const { meta } = uppy.getState();
			const body = JSON.stringify({ userId: meta.userId });
			const res = await fetch('/transloadit-params', {
				method: 'POST',
				body,
			});
			return res.json();
		},
	});
	return uppy;
}

function Component({ userId }) {
	// IMPORTANT: passing an initializer function to prevent the state from recreating.
	const [uppy] = useState(createUppy);

	useEffect(() => {
		if (userId) {
			uppy.setOptions({ meta: { userId } });
		}
	}, [uppy, userId]);
}
```

## HTTP uploads to your backend

If you want to handle uploads yourself, you can use
[`@uppy/xhr-upload`](/docs/xhr-upload).

```ts
// app/routes/api.upload.ts
import { json, unstable_parseMultipartFormData } from '@remix-run/node';
import type { ActionFunction } from '@remix-run/node';
import { writeFile } from 'node:fs/promises';
import path from 'node:path';

export const action: ActionFunction = async ({ request }) => {
	const formData = await request.formData();
	const file = formData.get('file') as File | null;

	if (!file) {
		throw json({ error: 'No file uploaded' }, { status: 400 });
	}

	const buffer = Buffer.from(await file.arrayBuffer());
	const filename = file.name.replace(/\s/g, '-');
	const filepath = path.join(process.cwd(), 'public', 'uploads', filename);

	try {
		await writeFile(filepath, buffer);
		return json({
			message: 'File uploaded successfully',
			filename,
		});
	} catch (error) {
		console.error('Error saving file:', error);
		throw json({ error: 'Error saving file' }, { status: 500 });
	}
};
```

```tsx
// app/routes/upload.tsx
import Uppy from '@uppy/core';
import Dashboard from '@uppy/react/lib/Dashboard';
import Xhr from '@uppy/xhr-upload';
import { useState } from 'react';

import '@uppy/core/dist/style.min.css';
import '@uppy/dashboard/dist/style.min.css';

function createUppy() {
	return new Uppy().use(Xhr, { endpoint: '/api/upload' });
}

export default function UppyDashboard() {
	// Important: use an initializer function to prevent the state from recreating.
	const [uppy] = useState(createUppy);

	return <Dashboard theme="dark" uppy={uppy} />;
}
```

## Next steps

- Add client-side file [restrictions](/docs/uppy/#restrictions).
- Upload files together with other form fields with [`@uppy/form`](/docs/form).
- Use your [language of choice](/docs/locales) instead of English.
- Add an [image editor](docs/image-editor) for cropping and resizing images.
- Download files from remote sources, such as [Google Drive](docs/google-drive)
  and [Dropbox](docs/dropbox), with [Companion](/docs/companion).
- Add [Golden Retriever](/docs/golden-retriever) to save selected files in your
  browser cache, so that if the browser crashes, or the user accidentally closes
  the tab, Uppy can restore everything and continue uploading as if nothing
  happened.

[transloadit-concepts]: https://transloadit.com/docs/getting-started/concepts/
[transloadit-services]: https://transloadit.com/services/
[react]: https://facebook.github.io/react
[tus]: https://tus.io/
[tus Node.js]: https://github.com/tus/tus-node-server
